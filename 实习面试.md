#  前端基础

## 1.h5的新特性？css3的新特性？

**H5新特性**

1. 拖拽释放api

2. 自定义属性data-id

3. 语义化标签

4. audio、video

5. canvas

6. 地理api

7. localStorage、sessionStorage

8. 表单控件

9. webworker、websocket

   | 不同点                                  | 备注说明                                                     |
   | --------------------------------------- | ------------------------------------------------------------ |
   | 只有一种 DOCTYPE ⽂件类型声明(统一标准) | `<!DOCTYPE html>`                                            |
   | 增加了一些新的标签元素(功能, 语义化)    | **section**, **video**, progress, **nav**, meter, time, **aside**, <br/>**canvas**, command, datalist, details, embed, figcaption, <br/>figure, **footer**, **header**, hgroup... |
   | input 支持了几个新的类型值              | `date, email, url` 等等                                      |
   | 新增了一些标签属性                      | charset（⽤于 meta 标签）；async（⽤于 script 标签）         |
   | 新增的全域属性                          | contenteditable, draggable... <br/>hidden...                 |
   | 新增API                                 | 本地存储, 地理定位, Canvas绘图, 拖拽API, 即时通信WebSocket... |

**css3新特性**

1. rgba (包含了颜色的红、绿、蓝和透明度（alpha）四个通道)
2. border-radius
3. 盒子模型
4. 线性渐变
5. 过渡
6. 动画
7. flex
8. 字体图标



## 2.盒子水平垂+/..直居中

1. 绝对定位 + transform：translate（-50%，-50%）
2. flex布局



## 3.css选择器优先级

！Important>行内样式>ID 选择器>类选择器>标签>通配符>继承>浏览器默-认属性



## 4.rem的理解

rem 是 CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。

手淘方案：

1. 拿到设计稿除以 10，得到 font-size 基准值
2. 引入 flexible
3. 设计稿 px/ font-size 基准值，即可换算为 rem



## 5.position

1. static 静态定位（默认值）：不脱离文档流
2. absolute 绝对定位 ：找最近一级带有定位的父级元素进行移动 脱离文档流
3. relative 相对定位  不脱离文档流
4. fixed 固定定位 脱离文档流 参照物浏览器窗口
5. sticky 粘性定位  不脱离文档流



## 6.浮动 float

浮动将元素排除在普通流之外，即元素将脱离文档流，不占据空间。浮动元素碰到包含它的边界或者浮动元素的边界停留。

1、子元素浮动后，不占位置，父元素的高度无法被撑开，影响与父元素同级的元素；

2、与浮动元素同级的非浮动元素（内联元素）会跟随其后；

3、若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决方法

清除浮动

1. 额外标签法  clear：both

2. 双伪元素清除法

3. 单伪元素清除法

4. 构建BFC  为父元素添加 `overflow: hidden`   溢出隐藏

5. 定高法

   



**何时会形成 BFC：**

满足下列条件之一就可触发BFC：

- HTML根元素
- position 值为 `absolute` 或 `fixed`
- float 值不为 `none`
- overflow 值不为 `visible`（为 hidden、scroll、auto时触发BFC）
- display 值为 `inline-block`、`table-cell` 或 `table-caption`

## 7. 伪类和伪元素

伪类：用于已有元素处于某种状态时为其添加对应的样式，这个状态是根据用户行为而动态变化的;	例如  `:checked`、`:hover`、`:disabled`、 `:first-child`等

伪元素：用于创建一些不在DOM树中的元素，并为其添加样式 ;	例如，我们可以通过  :before  :after



**两者的区别**

虽然它们在语法上是一致的，但是它们的功能区别还是非常明显的。

- 伪类是用来匹配元素的特殊状态的
- 伪元素是用来匹配元素的隶属元素的，这些隶属元素可以在界面中展示，但在 DOM 中不体现

## 8.css预处理器

Less、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率



Less和Sass是两种CSS预处理器，它们有以下区别：

1. 编译环境：Less基于JavaScript，在客户端处理；Sass基于Ruby，在服务器端处理。这可能导致一些开发者不会选择Less，因为JavaScript引擎需要额外的时间来处理代码，然后输出修改过的CSS到浏览器。但这可以通过在开发环节使用Less，一旦完成开发，就复制粘贴Less输出的样式到一个压缩器，然后到一个单独的CSS文件来替代Less文件，或者使用Less.app来编译和压缩Less文件等方式解决。
2. 变量声明：Less用@，Sass用$。
3. 混合器写法：Less和Sass在混合器的写法上有所不同。
4. 文件名：如果文件名以下划线开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件，而Less则没有这样的要求。
5. 工具库：Sass有工具库Compass，在其基础上封装了一系列有用的模块和模板，补充强化了Sass的功能；而Less则有UI组件库Bootstrap。

总的来说，Less和Sass在编译环境、变量声明、混合器写法、对文件名的要求以及工具库方面存在区别。

#### 两者区别

1. 实现方式：Less是基于JavaScript，在客户端进行处理；而Sass是基于Ruby，在服务器端进行处理。
2. 变量定义：在Less中，变量以@开头，如@mainColor: #963;而在Sass中，变量以$开头，如blue: #1875e7。

## 9.vw适配

- 开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注）
- 开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，换成vw为 (100/750)*32 vw
- 对于需要等比缩放的元素，CSS使用转换后的单位
- 对于不需要缩放的元素，比如边框阴影，使用固定单位px



## **10.如何解决 margin“塌陷”？**

**外边距塌陷共有两种情况：**

第一种情况：两个同级元素，垂直排列，上面的盒子给 margin-bottom 下面的盒子给margin-top，那么他们两个的间距会重叠，以大的那个计算。解决这种情况的方法为：两个外边距不同时出现

第二种情况：两个父子元素，内部的盒子给 margin-top，其父级也会受到影响，同时产生上边距，父子元素会进行粘连。

**解决方案：**

1、为父盒子设置 border，添加 border 后父子盒子就不是真正意义上的贴合（可以设置成透明：border：1px solid transparent）；

2、为父盒子添加 overflow：hidden；

3、为父盒子设定 padding 值；

4、为父盒子添加 position：fixed；

5、为父盒子添加 display：table；



## 11. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？

| 方式                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| opacity: 0            | 通过将元素的透明度设置为0，实现看起来隐藏的效果；但是依然会占用空间并可以进行交互 |
| visibility: hidden    | 与透明度为0的方案非常类似，会占据空间，但不可以进行交互      |
| overflow: hidden      | 只会隐藏元素溢出的部分；占据空间且不可交互                   |
| display: none         | 可以彻底隐藏元素并从文档流中消失，不占据空间也不能交互，且不影响布局 |
| z-index: -9999        | 通过将元素的层级置于最底层，让其他元素覆盖住它，达到看起来隐藏的效果 |
| transform: scale(0,0) | 通过将元素进行缩放，缩小为0；依然会占据空间，但不可交互,只是一个视觉效果，不会影响其它盒子的布局。 |
| left: -9999px         | 通过将元素定位到屏幕外面，达到看起来看不到的效果             |



## 12. 如何理解 z-index？

可以将它看做三维坐标系中的z轴方向上的图层层叠顺序。

元素默认的 z-index 为 0，可通过修改 z-index 来控制设置了postion 值的元素的图层位置。

`z-index的小坑, 如果父辈元素有定位, 且配置了z-index, 优先按照父辈元素的定位的z-index进行比较层级，当前盒子的z-index层级只是在父元素里面的层级`



## 13. 谈谈你对 flex 的理解？

在真实的应用场景中，通常会遇到各种各样不同尺⼨和分辨率的设备，为了能在所有这些设备上正常的布局我们的应用界面，就需要响应式的界⾯设计方式来满⾜这种复杂的布局需求。

flex 弹性盒模型的优势在于开发⼈员只需要声明布局应该具有的⾏为，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对⻬的场景时，就要优先考虑弹性盒子布局。 

你能联想到的flex语法有哪些呢?

`flex-direction`: 调整主轴方向

```txt
row：主轴方向为水平向右
column：主轴方向为竖直向下
row-reverse:主轴方向为水平向左
column-reverse:主轴方向是竖直向上。
```

`justify-content`主要用来设置**主轴方向的对齐方式**

```
flex-start: 弹性盒子元素将向起始位置对齐
flex-end: 弹性盒子元素将向结束位置对齐。
center: 弹性盒子元素将向行中间位置对齐
space-around: 弹性盒子元素会平均地分布在行里
space-between:第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。
```

`align-items`用于调整**侧轴的对齐方式**

```txt
flex-start： 元素在侧轴的起始位置对齐。 
flex-end： 元素在侧轴的结束位置对齐。
center： 元素在侧轴上居中对齐。
stretch： 元素的高度会被拉伸到最大（不给高度时, 才拉伸）。
```

`flex-wrap`属性控制flex容器是单行或者多行,默认不换行

```txt
nowrap： 不换行（默认），如果宽度溢出，会压缩子盒子的宽度。
wrap： 当宽度不够的时候，会换行。
```

`align-content`用来设置多行的flex容器的排列方式

```txt
flex-start： 各行向侧轴的起始位置堆叠。 
flex-end： 各行向弹性盒容器的结束位置堆叠。
center： 各行向弹性盒容器的中间位置堆叠。
space-around： 各行在侧轴中平均分布。 
space-between： 第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布。 
stretch：拉伸，不设置高度的情况下。
```

> 可参考 [flex布局教程](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

---





# JavaScript



## 1. let var const的区别？

**var ES5变量声明方式**

1. 在变量未赋值时，变量undefined（为使用声明变量时也为undefined）
2. 作用域： var的作用域为方法作用域；只要在方法内定义了，整个方法内的定义变量后的代码都可以使用

**let ES6变量声明方式**

1. 在变量为声明前直接使用会报错
2. 作用域   let为块级作用域   通常let比var范围要小
3. let禁止 重复声明变量，否则会报错；var可以重复声明

**const ES6变量声明**

1. const为常量声明方式；声明变量时必须初始化，在后面出现的代码中不能再修改常量的值
2. const实际上保证的，并不是变量的值不得改动，而是变量指向的哪个内存地址不得改动



## 2. js数据类型，区别

**基本数据类型：**

number，string，boolean，null，undefined，symbol，bigint

**引用数据类型：**

- Object（对象）
- Function（函数）
- Array（数组）

object：普通对象，数组对象，正则对象，日期对象，math数学函数对象。

(NaN 是一个数值类型，但不是一个具体的数字。)



## 3.slice 是干嘛的、splice是否会改变原数组？

1. slice 是来截取的  参数可以写 slice(3)、slice(-3)、slice(1,3) 返回的是一个新的数组

2. splice 功能有：插入、删除、替换

   返回：删除的值

   该方法会改变原数组



## 4.数组去重

```js
const arr = [1,2,3,2]

function unique(arr) {
    return [...new Set(arr)]
}
console.log(unique(arr))
```



## 5. **Javascript 创建对象的几种方式？**

1. 简单对象的创建 使用对象字面量的方式{}

```javascript
const Cat = {};
```

2. --new 一个function-

```javascript
function Person(){
}
const personOne=new Person();
```

3. 使用工厂方式来创建（Object 关键字）

```javascript
const wcDog =new Object();
```

4. 使用 Object.create() 创建对象（使用现有对象作为原型）

```javascript
const person = Object.create(anotherPerson);
```

5. 使用 ES6 中的类（Class）创建对象（其实质还是使用构造函数）：

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}
const person = new Person('John');
```



## 6. 如何区分数组和对象？

1. 通过 ES6 中的 Array.isArray

```javascript
Array.isArray([]) //true
Array.isArray({}) //false
```

2. 通过 instanceof 来识别

```javascript
[] instanceof Array //true
{} instanceof Array //false
```

3. 通过调用 constructor 来识别

```javascript
{}.constructor //返回 object
[].constructor //返回 Array
```

4. 通过 Object.prototype.toString.call 方法来识别

```javascript
Object.prototype.toString.call([]) //["object Array"]
Object.prototype.toString.call({}) //["object Object"]
```



## 7. 作用域和作用域链

作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离
变量，不同作用域下同名变量不会有冲突。

全局作用域 和 局部作用域（分为 函数作用域 和 块级作用域）

1. ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。
2. ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现



**什么是作用域链？**

作用域链本质上是底层的变量查找机制。

在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域。

总结：

1. 嵌套关系的作用域串联起来形成了作用域链
2. 相同作用域链中按着从小到大的规则查找变量
3. 子作用域能够访问父级作用域，父级作用域无法访问子级作用域

- 当代码在一个环境中执行时，会创建变量对象的一个作用域链

- 由子级作用域返回父级作用域中寻找变量，就叫做作用域链

- 作用域链中的下一个变量对象来自包含环境，也叫外部环境。而再下一个变量对象则来自中的最后一个对象

- 作用域链前端始终都是当前执行的代码所在环境的变量对象，如果环境是函数，则将其活动对象作为变量对象

**如何延长作用域链？**

执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除，具体来说就是执行这两个语句时，作用域链都会得到加强

1. try - catch 语句的 catch 块；会创建一个新的变量对象，包含的是被抛出的错误对象的声明

2. with 语句。with 语句会将指定的对象添加到作用域链中



## 8. map 和 forEach 的区别？

**相同点：**

1. 都是循环遍历数组中的每一项
2. 每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），
   arr（原数组）
3. 匿名函数中的this都是指向window
4. 只能遍历数组

**不同点：**

1. map()会分配内存空间存储新数组并返回，forEach()不会返回数据。
2. forEach()允许callback更改原始数组的元素。map()返回新的数组。



## 9. js遍历对象的方法？

1. `for...in` 循环
2. `Object.keys()` 方法   获取对象中所有的键  对应 object.value
3. `Object.entries()` 方法



## 10. new操作符具体干了什么呢?

1. 创建新对象
2. 构造函数this指向新对象
3. 执行构造函数代码，修改this，添加新的属性
4. 返回新对象



## 11.伪（类）数组转换为数组

- 使用 Array.from()
- 使用 Array.prototype.slice.call()
- 使用 Array.prototype.forEach() 进行属性遍历并组成新的数组



### 数组和伪数组的区别?

1. 定义

- 数组是一个特殊对象,与常规对象的区别：
  - 当由新元素添加到列表中时，自动更新length属性
  - 设置length属性，可以截断数组
  - 从Array.prototype中继承了方法
  - 属性为'Array'
- 伪数组是一个拥有length属性，并且他属性为非负整数的普通对象，伪数组不能直接调用数组方法。

2. 区别
   本质：伪数组数组是简单对象，它的原型关系与数组不同

## 12.简单说说 js 中有哪几种内存泄露的情况

1. 意外的全局变量；
2. 闭包；
3. 未被清空的定时器；
4. 未被销毁的事件监听；
5. DOM 引用；



###### 闭包一定会造成内存泄漏吗？

在一般情况下，只要正确使用闭包，避免长期占用内存，就不会导致内存泄漏。



## 13. promise和 async await 区别?

**概念**
Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强
大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而
这些结果一旦生成是无法改变的
async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执
行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象
**两者的区别**

1. Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向
   发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async
   await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同
   于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。
2. async await与Promise一样，是非阻塞的。
3. async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函
   数。



## 14. defer和async区别?

- `defer`要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行。多个defer脚本会按照它们在页面出现的顺序加载。==“渲染完再执行”==
- `async`一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。多个async脚本是不能保证加载顺序的。==“下载完就执行”==

**延迟加载有哪些js方式？**

1. **defer** : 等 html 全部解析完成，才会执行 js 代码，顺次执行 js 代码。
2. **async**：async 和 html 解析是同步的（一起的），不是顺次执行 js 脚本（谁先加载完谁先执行）



## 15. 同步和异步

**同步**

- 指在 主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。
- 也就是调用一旦开始，必须这个调用 返回结果(划重点——）才能继续往后执行。程序的执行顺序
  和任务排列顺序是一致的。

**异步**

- 异步任务是指不进入主线程，而进入 任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。
- 每一个任务有一个或多个 回调函数。前一个任务结束后，不是执行后一个任务,而是执行回调函数，后一个任务则是不等前一个任务结束就执行。
- 程序的执行顺序和任务的排列顺序是不一致的，异步的。
- 我们常用的setTimeout和setInterval函数，Ajax都是异步操作。



## 16. null 和 undefined 的区别

**1. undefined（未定义）**:

- 当你声明一个变量但没有初始化时，该变量的值是`undefined`。
- 函数中没有返回值时，默认返回`undefined`。
- 对象属性没有赋值时，该属性的值是`undefined`。
- 函数参数没有传递值时，参数的默认值是`undefined`



**2. null（空值）**:

- `null`通常是程序员主动赋予变量的一种值，表示该变量被明确地设置为“空”或“不存在”。
- 当你想要表示一个空对象时，可以将其赋值为`null`。
- `undefined`通常表示缺少值，而`null`通常表示被故意设置为空



## 17. call appy bind的作用和区别？

**作用：**

都可以改变函数内部的this指向（第一个参数是指定this指向对象）

**区别点：**

1. call 和 apply 会调用函数，并且改变函数内部this指向。
2. call 和 apply 传递的参数不一样，call 传递参数arg1,arg2...形式 apply 必须数组形式[arg]
3. bind 不会调用函数，可以改变函数内部this指向

应用场景

1. object.prototype.toString.call()  检测数据类型
2. apply 经常和数组有关系，比如借助于数学对象实现数组的最大值最小值
3. bind：比如改变定时器内部 的this 指向



## 18. this指向（普通函数、箭头函数）

1. 谁调用了函数或者方法，那么这个函数或者对象中的this就指向谁
2. 匿名函数中的this：匿名函数的执行具有全局性，则匿名函数中的this指向是window，而不是调用该匿名函数的对象

**箭头函数中的this**

* 箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的
* 箭头函数中的this指向父级作用域的执行上下文；
* 箭头函数无法使用apply、call和bind方法改变this指向，因为其this值在函数定义的时候就被确定下来



## 19. 继承

继承一些属性，构造的过程和方法

**继承的好处**

a：提高了代码的复用性

b：提高了代码的维护性

c：让类与类之间产生了关系，是多态的前提

**继承的弊端**

类的耦合性增强了,但是开发的原则：高内聚，低耦合

1. 构造函数继承
2. 原型链继承
3. 原型式继承
4. 组合继承
5. 寄生式继承
6. 寄生组合式继承
7. class extends 继承



## 20. promise

promise的设计之初就是为了解决回调地狱的问题的。

本意是承诺，**这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了**

**Promise的三种状态**

- Pending----Promise对象实例创建时候的初始状态

- Fulfilled----可以理解为成功的状态
- Rejected----可以理解为失败的状态

```js
let p = new Promise((resolve, reject) => {
    reject('reject')
    resolve('success')//无效代码不会执行
})
p.then( value => {
    console.log(value)
},
reason => {
	console.log(reason)//reject
})
```

当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的

```js
new Promise((resolve, reject) => {
    console.log('1')
    resolve('success')
})
console.log('2')
```

promise的链式调用

如果上一个.then中返回一个新的promise对象，则可以交给下一个.then继续处理。

- 每次调用返回的都是一个新的Promise实例(这就是then可用链式调用的原因)
- 如果then中返回的是一个结果的话会把这个结果传递下一次then中的成功回调
- 如果then中出现异常,会走下一个then的失败回调
- 在 then中使用了return，那么 return 的值会被Promise.resolve() 包装
- catch 会捕获到没有捕获的异常

```js
Promise.resolve(1)
.then(res => {
console.log(res)
return 2 //包装成 Promise.resolve(2)
})
.catch(err => 3)
.then(res => console.log(res))

ajax(url).then(res => {
	console.log(res)
	return ajax(url1)
}).then(res => {
	console.log(res)
	return ajax(url2)
}).then(res => console.log(res))
```

存在一个缺点：无法取消promise，**错误需要通过回调函数捕获**

场景：

1. 异步请求
2. 定时器
3. 并行异步操作  当需要同时进行多个异步操作，并在它们都完成后执行一些任务时，可以使用 Promise.all 方法。
4. 串行异步操作

**promise静态常用的方法**

1. promise.all（[promise1,promise2...]）  等待机制  等待完才会走 .then
2. promise.race   赛跑机制

## 21、JavaScript 内置的常用对象有哪些？

**对象及方法**

Arguments 函数参数集合

Arguments[ ] 函数参数的数组

Arguments 一个函数的参数和其他属性

Arguments.callee 当前正在运行的函数

Arguments.length 传递给函数的参数的个数

**Array 数组**

length 属性 

join() 将一个数组转成字符串。返回一个字符串。

reverse() 将数组中各元素颠倒顺序

delete 运算符 只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)。

shift() 删除数组中第一个元素，返回删除的那个值，并将长度减 1。

pop() 删除数组中最后一个元素，返回删除的那个值，并将长度减 1。

unshift() 往数组前面添加一个或多个数组元素，长度要改变。arrObj.unshift(“a” ，“b，“c”)

push() 往数组结尾添加一个或多个数组元素，长度要改变。arrObj.push(“a” ，“b”，“c”)

concat( ) 连接数组

slice( ) 返回数组的一部分

sort( ) 对数组元素进行排序

splice( ) 插入、删除或替换数组的元素

toLocaleString( ) 把数组转换成局部字符串

toString( ) 将数组转换成一个字符串

forEach 遍历所有元素

every 判断所有元素是否都符合条件

sort 排序

map 对元素重新组装，生成新数组

filter 过滤符合条件的元素

**String 字符串对象**

Length 获取字符串的长度。

toUpperCase() 将字符串中的字母转成全大写。如：strObj.toUpperCase()

charAt(index) 返回指定下标位置的一个字符。如果没有找到，则返回空字符串

substr() 在原始字符串，返回一个子字符串

substring() 在原始字符串，返回一个子字符串

split() 将一个字符串转成数组

charCodeAt( ) 返回字符串中的第 n 个字符的代码

concat( ) 连接字符串

fromCharCode( ) 从字符编码创建—个字符串

indexOf( ) 返回一个子字符串在原始字符串中的索引值(查找顺序从左往右查找)。如果没有找到，则返回-1

lastIndexOf( ) 从后向前检索一个字符串

localeCompare( ) 用本地特定的顺序来比较两个字符串

match( ) 找到一个或多个正则表达式的匹配

replace( ) 替换一个与正则表达式匹配的子串

search( ) 检索与正则表达式相匹配的子串

slice( ) 抽取一个子串

toLocaleLowerCase( ) 把字符串转换小写

toLocaleUpperCase( ) 将字符串转换成大写

toLowerCase( ) 将字符串转换成小写

toString( ) 返回字符串

toUpperCase( ) 将字符串转换成大写

valueOf( )



## 22.谈谈事件委托的理解？

JavaScript 事件代理则是一种简单的技巧，把事件处理器添加到一个上级元素上，这样就避免了把事件处理器添加到多个子级元素

。这主要得益于浏览器的事件冒泡机制。

**优点：**

1、减少事件注册，节省内存。

5、不用在新添加的 li 上绑定 click 事件。

**缺点：**

1、事件委托基于冒泡，对于不冒泡的事件不支持

2、层级过多，冒泡过程中，可能会被某层阻止掉。

+

## 23.什么是闭包？



++MDN的官方解释：

> 闭包是函数和声明该函数的词法环境的组合

更通俗一点的解释是：

> 内层函数, 引用外层函数上的变量, 就可以形成闭包

**定义：**

 一个作用域可以访问到另外一个函数内部的局部变量，或者说一个函数（子函数）访问另一个函数（父函数）中的变量。此时就会产生闭包，那么这个变量所在的函数我们就称之为闭包函数。

```js
function aaa() {
    let a = 0
    return function() {
        alert(a++)
    }
}

let fun = aaa()
fun()              // 1
```

**优缺点：**

闭包的主要作用：延伸了变量的作用范围，因为闭包函数中的变量不会等着闭包函数执行完就销毁，因为还有别的函数要调用它，只有等着所有的函数都调用完了它才会销毁。 **实现数据的私有。**

优点:

1）可以减少全局变量的定义，避免全局变量的污染

2）能够读取函数内部的变量

3）在内存中维护⼀个变量，可以⽤做缓存

缺点:

1）可能造成内存泄露

2）闭包可能在⽗函数外部，改变⽗函数内部变量的值。

3）造成性能损失

使用场景：

1. 封装私有变量
2. 闭包可以用于创建模块化的代码结构，避免全局变量的污染。
3. 在处理用户输入或频繁触发的事件时，可以通过闭包来实现防抖（debounce）和节流（throttle）的效果。防抖和节流是优化性能和减少不必要请求的常见方法。
4. 缓存数据：通过闭包，可以在函数内部缓存一些计算结果或其他重要数	据，避免重复计算或请求。



## 24.for in 和 for of 的区别

1、推荐在循环对象属性的时候使用 for...in，在遍历数组的时候的时候使用 for...of

2、for...in 循环出的是 key，for...of 循环出的是 value

3、注意，for...of 是 ES6 新引入的特性。修复了 ES5 引入的 for...in 的不足

4、for...of 不能循环普通的对象，需要通过和 Object.keys()搭配使用



## 25、split（）和 join（）的区别？

split()是把一串字符（根据某个分隔符）分成若干个元素存放在一个数组里即切割成数组的形式；

join() 是把数组中的字符串连成一个长串，可以大体上认为是 split()的逆操作



## 26.深拷贝

> 首先浅拷贝和深拷贝只针对引用类型

**浅拷⻉**: 拷贝的是地址

拷贝对象

1. object.assign() 
2.   展开运算符

拷贝数组

1. object.prototype.concat()

如果是简单数据类型拷贝值，不会影响原对象，引用数据类型拷贝的是地址。



**深拷⻉**: 拷贝的是对象，不是地址

1. 递归
2. JSON 对象中的 parse 和 stringify
3. lodash 库 里的 cloneDeep

```js
⽬前实现深拷⻉的主要是利⽤ JSON 对象中的 parse 和 stringify  

const originArray = [1,2,3,4,5];

const cloneArray = JSON.parse(JSON.stringify(originArray));

console.log(cloneArray === originArray); // false
```

用到？

1. 处理嵌套对象和数组：创建一个独立的副本。这样，对副本的修改不会影响原始数据。
2. 操作不可变的数据
3. 序列化和反序列化：当你需要将对象转换为字符串进行存储或传输时，深拷贝可以帮助你创建一个完整的副本，并且在后续需要时可以还原为原始对象。



## 27.原型链

**原型**

1. 构造函数通过原型分配的函数是所有对象所共享的
2. js 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象。
3. 这个对象可以挂载函数，对象实例化不会多次创建原型上的函数，节约内存。
4. 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。
5. 构造函数和原型对象中的this 都指向实例化对象。

**constructor属性**

每个原型对象里面都有个 constructor 属性，该属性指向该原型对象的构造函数。

使用场景：

如果有多个对象的方法，我们可以给原型对象采取 对象形式赋值。

但是这样就会覆盖构造函数原型对象原来的内容。

这样修改后的原型对象 constructor 就不再指向当前构造函数了。

此时，我们应该在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。

**对象原型 --proto--**

实例对象的原型，对象都有一个属性 --proto--，指向构造函数的 prototype 原型对象。

之所以我们对象可以使用构造函数prototype原型对象上的方法和属性，就是因为对象有--proto--原型的存在。

**原型链：**

所有的实例对象里面都有--proto--对象原型，指向原型对象

所有的原型对象里面有 constructor，指向创造该原型对象的构造函数

1. 当访问一个对象的属性和方法时，首先查找这个对象本身有没有该属性
2. 如果没有就查找它的原型（也就是--proto--指向的prototype原型对象）
3. 如果还没有就查找原型对象上的原型
4. 依此类推，一直找到为止
5. --proto--对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。
6. 可以使用 instanceof 运算符用于检测构造函数的prototype 属性是否出现在某个实例对象的原型链上。



## 28.防抖和节流

**防抖(debounce)**：触发⾼频事件后 n 秒内函数只会执⾏⼀次，如果 n 秒内⾼频事件再次被触发，则重新计算时间

使用场景：

1. 搜索框防抖																																																																																																																																																																																																																																																																																																																																																																																																																																																																																											
2. 手机号、邮箱验证输入检测

**手写防抖函数**：

思路：防抖的核心就是利用 settimeout 实现的

1. 声明一个定时器变量
2. 当鼠标每次滑动都先判断 是否有定时器了，如果有定时器先清除以前的定时器
3. 如果没有定时器则开启定时器，记得存到变量里面
4. 在定时器里面调用要执行的函数

```js
function debounce(fn,t) {
    let timeId
    return function() {
        if(timeId) clearTimeout(timeId)
        timeId = setTimeout(function() {
           fn() 
        },t)
    }
}
box.addEventListener('mousemove',debounce(mouseMove,500))
```



**节流(throttle)**：⾼频事件触发，但在 n 秒内只会执⾏⼀次，所以节流会稀释函数的执⾏频率

使用场景：

1. 小米轮播图切换点击效果
2. 页面尺寸缩放resize
3. 滚动条滚动

**手写节流函数**

思路：一样

1. 声明一个定时器变量
2. 当鼠标每次滑动都先判断 是否有定时器了，如果有定时器，则不开启新定时器
3. 如果没有定时器则开启定时器，记得存到变量里面
4. 定时器里面调用执行的函数
5. 清空定时器

```js
function throttle(fn,t) {
    let timeId = null
    return function() {
        if(!timeId) {
            timeId = setTimeout(function() {
               fn()
                timeId = null
            },t)
        }
    }
}
box.addEventListener('mousemove',throttle(mouseMove,500))
```



区别：防抖动是将多次执⾏变为最后⼀次执⾏，节流是将多次执⾏变成每隔⼀段时间执⾏。



## 29.ES6

1. let  const
2. 模板字符串
3. 箭头函数
4. object.keys() 遍历对象的键
5. object.assign() 合并对象 常用于对象拷贝
6. for of
7. import（用于在一个模块中加载另一个含有 export 接口的模块）  export（用于对外输出本模块）
8. promise
9. set
10. class



## 30.介绍下 Set、Map 的区别

**区别**

应用场景 Set 用于数据重组，Map 用于数据储存

Set：

成员不能重复

只有值没有键名，类似数组

可以遍历，方法有 add, delete,has

Map: 

本质上是健值对的集合，类似集合

可以遍历，可以跟各种数据格式转换



## 31.async await

1. async 用于修饰一个函数，表示一个函数是异步的
2. await 要用在 async 函数中
3. await 后面一般会跟一个 promise 对象
4. await 只会等待 promise 成功的结果



# 浏览器

## 1.cookie sessionStorage localStorage区别

**共同点：**

都是保存在浏览器端、且同源的

**区别：**

1.  cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 

2.  存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 

3.  数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 

4.  作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 

5.  web Storage支持事件通知机制，可以将数据更新的通知发送给监听者
6.  Storage的api接口使用更方便



| 方式名称       | 标准说明     | 功能说明                                                     |
| -------------- | ------------ | ------------------------------------------------------------ |
| Cookie         | HTML5 前加入 | 1.会为每个请求自动携带所有的Cookie数据，比较方便，但是也是缺点，浪费流量；<br>2.每个domain(站点)限制存储20个cookie；<br/>3.容量只有4K<br/>4.浏览器API比较原始，需要自行封装操作。 (js-cookie) |
| localStorage   | HTML5 加入   | 1.兼容IE8+，操作方便；<br/>2.永久存储，除非手动删除；<br/>3.容量为5M |
| sessionStorage | HTML5 加入   | 1.功能基本与 localStorage 相似，但当前页面关闭后即被自动清理；<br/>2.与Cookies、localStorage 不同点是不能在所有同源窗口间共享，属于会话级别的存储 |
| Web SQL        | 非标准功能   | 1.2010年已被废弃，但一些主流浏览器中都有相关的实现；<br/>2.类似于 SQLite 数据库，是一种真正意义上的关系型数据库，⽤SQL进⾏操作； |
| IndexedDB      | HTML5 加入   | 1.是一种 NoSQL 数据库，⽤键值对进⾏储存，可进⾏快速读取操作；<br/>2.适合复杂 Web存储场景，⽤JS操作⽅便 (前端大量存数据的场景较少, 如果有, 可以用) <br />3.存储空间容量, 大于等于 250MB，甚至没有上限 |

## 2. 浏览器输入URL发生了什么

1. URL 解析
2. DNS 查询
3. TCP 连接
4. 处理请求
5. 接受响应
6. 渲染页面



## 3. 浏览器是如何渲染页面的？

不同浏览器内核渲染机制有所区别

1. HTML 被 HTML 解析器解析成 DOM 树；
2. CSS 被 CSS 解析器解析成 CSSOM 树；
3. 结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；
4. 生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；
5. 将布局绘制(paint)在屏幕上，显示出整个页面。



## 4. 重绘、重排

**概念**

1. 重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树
2. 重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等

**区别：**

重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）

**引发重排**

1. 添加、删除可见的dom
2. 元素的位置改变
3. 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)
4. 页面渲染初始化
5. 浏览器窗口尺寸改变
6. 获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存

**优化方案**

浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘

减少 reflow/repaint：

1. 不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的className。

2. 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。

3. 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会reflow 的。

4. 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)

5. 不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）



## 5. 事件循环（Event loop）

js执行主线程代码是一行一行往下执行的，js是单线程的，所以遇到异步的函数，他会将异步函数交给浏览器，浏览器是多线程的，可以处理多件事情，如果满足条件就会将需要执行的内容放到任务队列中，只有主线程空闲了，才会执行任务队列的代码。主线程从"任务队列"中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环****



js 是一门单线程执行的语言。也就是说，同一时间只能做一件事情。

为了防止某个耗时任务导致程序假死的问题，异步代码由js 委托给宿主环境（浏览器、node环境）等待执行。

**JavaScript 的事件分两种**

1. 宏任务：包括整体代码 script，setTimeout，setInterval
2. 微任务：Promise.then(非 new Promise是同步的)，catch、process.nextTick(node 中)

**具体执行：**

事件的执行顺序——先执行宏任务，然后执行微任务，任务有同步的任务和异步的任务，同步的进入主线程，异步的进入 Event Table 并注册函数，异步事件完成后，会将回调函数放在队列中，如果还有异步的宏任务，那么就会进行循环执行上述的操作

主 线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查微任务队列是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有微任务。然后再进入下一个循环去 从任务队列中取下一个任务执行

**详细步骤**：

1. 选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。

2. 将事件循环的当前运行宏任务设置为已选择的宏任务。
3. 运行宏任务。
4. 将事件循环的当前运行任务设置为null。
5. 将运行完的宏任务从宏任务队列中移除。
6. microtasks步骤：进入microtask检查点。
7. 更新界面渲染。
8. 返回第一步。



## 6. 跨域

**跨域是什么？**

跨域（Cross-Origin）指的是在浏览器中，当一个请求的源（Origin）与目标资源的源不一致时，即发生跨域访问。在默认情况下，浏览器的同源策略（Same-Origin Policy）会阻止这种跨域访问。同源策略是为了保护用户的信息安全，防止恶意网站对其他网站的资源进行访问和操作。

**同源策略规定几个约束**

1. 协议相同
1. 域名相同
1. 端口号相同

**同源策略限制内容有**

- cookie、localstorage、indexedDB 等
- dom节点
- ajax 请求

**跨域解决⽅法：**

1、jsonp⽅式

2、代理服务器的⽅式

3、服务端允许跨域访问(CORS)

4、取消浏览器的跨域限制



## 7.常见code码

1. 200 - 请求成功。
2. 301 - 永久重定向。
3. 302 - 临时重定向。
4. 304 - 未修改。
5. 400 - 请求错误。
6. 401 - 未授权。
7. 403 - 禁止访问。
8. 404 - 资源不存在。
9. 500 - 服务器错误。
10. 503 - 服务不可用。



## 8. http 和 https 的区别

1. **安全性：**
   - **HTTP：** 数据以纯文本形式传输，不进行加密。这使得HTTP在传输过程中容易受到窃听和中间人攻击的威胁。因此，不建议在处理敏感信息（如信用卡号、登录凭据等）的网页上使用纯HTTP。
   - **HTTPS：** 数据通过使用TLS/SSL协议进行加密，因此更加安全。加密的数据传输使得窃听者很难理解或篡改传输的数据。

2. **协议：**
   - **HTTP：** 使用的是标准的HTTP协议。
   - **HTTPS：** 在HTTP的基础上添加了TLS/SSL协议，通过在传输层对数据进行加密和身份验证来提供安全性。
3. **默认端口：**
   - **HTTP：** 默认端口是80。
   - **HTTPS：** 默认端口是443。
4. **证书：**
   - **HTTP：** 不需要证书。
   - **HTTPS：** 需要使用SSL证书，用于在客户端和服务器之间建立安全连接。证书通过第三方机构（Certificate Authorities）颁发，用于验证网站的身份。
5. **搜索引擎排名：**
   - **HTTP：** 某些搜索引擎可能更喜欢HTTPS网站，因为它们提供更安全的用户体验。
   - **HTTPS：** 使用HTTPS的网站在搜索引擎排名中可能会得到一些额外的优势。



## 9. 前端优化策略

1、减少http请求数

2、将脚本往后挪，减少对并发下载的影响

3、避免频繁的DOM操作

4、压缩图⽚

5、gzip压缩优化，对传输资源进⾏体积压缩(html,js,css)

6、按需加载

7、组件化

8、减少不必要的Cookie（Cookie存储在客户端，伴随着HTTP请求在浏览器和服务器之间传递，由于cookie在访问对应域名下的资源时都会通过HTTP请求发送到服务器，从⽽会影响加载速度，所以尽量减少不必要的Cookie。）



## 10.介绍一下 websocket

它是建立于单个TCP连接上的全双工通信协议，允许客户端和服务端进行实时数据传输



websocket 是一种网络通信协议，是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通 信的协议，这个对比着 HTTP 协议来说，HTTP 协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。HTTP 协议无法实现服务器主动向客户端发起消息，websocket 连接允许客户端和服务器之间进行全双工通信， 以 便 任一方都可以通过建立的连接将数据推送到另一端。websocket 只需要建立一次连接， 就 可 以一直保持连接状态



## 11.webpack

Webpack是一个静态模块打包工具，用于分析、压缩和打包代码



Webpack配置文件通常是一个名为webpack.config.js的JavaScript文件



Webpack的配置主要涉及以下内容：

1. 入口(entry)：指定Webpack编译的入口文件。
2. 输出(output)：指定编译后文件的输出位置和名称。
3. 加载器(loader)：将非JavaScript文件（如CSS，图片等）转换为Webpack可以处理的模块。
4. 插件(plugin)：用于实现Webpack的各种功能，如打包优化、资源管理和环境变量注入等。

| 名称     | 内容                                                         |
| :------- | :----------------------------------------------------------- |
| 代码转换 | typescript编译成JavaScript、scss编辑成css                    |
| 文件优化 | 压缩JavaScript、css、html、压缩合并图片                      |
| 代码分割 | 提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载 |
| 模块合并 | 采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件 |
| 自动刷新 | 监听本地源代码的变化，自动构建，刷新浏览器                   |
| 代码校验 | 在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过 |
| 自动发布 | 更新完代码后，自动构建出线上发布代码并传输给发布系统         |

## **12.Get 和 Post 的区别以及使用场景**

**区别**

1、Get 使用 URL 或 Cookie 传参。而 Post 将数据放在 body 中

2、Get 的 URL 会有长度上的限制，则 Post 的数据则可以非常大

3、Post 比 Get 安全，因为数据在地址栏上不可见



|                  | GET方法                                                      | POST方法                                           |
| ---------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| **数据传输⽅式** | 通过URL传输数据 (地址栏拼接参数)                             | 通过请求体传输                                     |
| **数据安全**     | 数据暴露在URL中，可通过浏览历史记录、缓存等很容易查到数据信息 | 数据因为在请求主体内，<br />所以有⼀定的安全性保证 |
| **数据类型**     | 只允许 ASCII 字符                                            | ⽆限制                                             |
| **GET⽆害**      | 刷新、后退等浏览器操作是⽆害的                               | 可能会引起重复提交表单                             |
| **功能特性**     | 安全且幂等（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化。<br />**幂等的概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同）** | ⾮安全(会引起服务器端的变化)、**⾮幂等**           |

**最本质的区别**

基于 http 协议进行请求， 其实 GET 和 POST 无区别， 只是请求时的方式不同， 都可以携带请求体， 也可以在 URL 带参数区别来自于浏览器对 URL 长度的限制， 请求体大小来源于服务器的限制

**还有语义的区别：**

GET 是获取， POST 是提交

Get 是用来从服务器上获得数据，而 post 是用来向服务器上传递数据



## 13. HTTP有哪些⽅法？

HTTP 1.0 标准中，定义了3种请求⽅法：GET、POST、HEAD

HTTP 1.1 标准中，新增了请求⽅法：PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT



## 14. 各个HTTP方法的具体作用是什么？

|  方法   | 功能                                                         |
| :-----: | ------------------------------------------------------------ |
|   GET   | 通常⽤于请求服务器发送某些资源                               |
|  POST   | 发送数据给服务器                                             |
|  HEAD   | 请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致。<br />该请求⽅法的⼀个`使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源` |
|   PUT   | ⽤于全量修改⽬标资源 (看接口, 也可以用于添加)                |
| DELETE  | ⽤于删除指定的资源                                           |
| OPTIONS | ⽤于获取⽬的资源所⽀持的通信选项 (跨域请求前, 预检请求, 判断目标是否安全) |
|  TRACE  | 该方法会  让服务器  原样返回任意客户端请求的信息内容, 用于诊断和判断 |
| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道⽅式的代理服务器<br />(把服务器作为跳板，让服务器代替用户去访问其它网页, 之后把数据原原本本的返回给用户) |
|  PATCH  | ⽤于对资源进⾏部分修改                                       |

GET POST PUT PATCH DELETE

GET/DELETE  参数是在地址栏中传递的

PUT/PATCH/POST 参数是在请求体传递的



# Vue

## 1.谈谈你对 Vue 生命周期的理解？

**（1）生命周期是什么？**

Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期

**（2）各个生命周期的作用**

| beforeCreate  | 组件实例创建之前，组件实例被创建之初，组件的属性生效之前     |
| :------------ | :----------------------------------------------------------- |
| created       | 组件实例创建完成之后，组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，\$el 还不可用 |
| beforeMount   | 组件挂载开始之前，在挂载开始之前被调用：相关的 render 函数首次被调用 |
| mounted       | 组件挂载开始之后，el 被新创建的 vm.\$el 替换，并挂载到实例上去之后调用该钩子 |
| beforeUpdate  | 组件数据更新之前，组件数据更新之前调用，发生在虚拟 DOM 打补丁之前 |
| updated       | 组件数据更新之后                                             |
| activited     | 组件被激活时，keep-alive 专属，组件被激活时调用              |
| deadctivated  | 组件失活时，keep-alive 专属，组件被销毁时调用                |
| beforeDestory | 组件销毁前调用                                               |
| destoryed     | 组件销毁后调用                                               |



## 2. keep-alive

**1、什么是keep-alive？**

keep-alive 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，⽽不是销毁它们。keep-alive 是⼀个抽象组件：它⾃身不会渲染成⼀个 DOM 元素，也不会出现在⽗组件链中

**2、keep-alive的优点**？

在组件切换过程中 把切换出去的组件保留在内存中，防⽌重复渲染DOM，减少加载时间及性能消耗，提⾼⽤户体验性。

**3、keep-alive有三个属性**

include ： 只有匹配的组件会被缓存

exclude ： 任何匹配的组件都不会被缓存

max ： 最多可以缓存多少组件实例

**4、keep-alive的使⽤会触发两个⽣命周期函数？**

这两个函数分别是

activated 当组件被激活（使⽤）的时候触发 可以简单理解为进⼊这个⻚⾯的时候触发

deactivated 当组件不被使⽤的时候触发 可以简单理解为离开这个⻚⾯的时候触发



## 3. 数据双向绑定原理

数据变化更新视图

* 输入框内容变化时，Data 中的数据同步变化。即 View => Data 的变化。
* Data 中的数据变化时，文本节点的内容同步变化。即 Data => View 的变化

vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的⽅式来实现的.

 数据劫持、vue是通过Object.defineProperty()来实现数据劫持，

 其中会有getter()和setter⽅法；当读取属性值时，就会触发getter()⽅法，

 在view中如果数据发⽣了变化，就会通过Object.defineProperty( )对属性设置⼀个setter函数，

 当数据改变了就会来触发这个函数；

实现一个监听器 ->实现一个解析器 -> 实现一个订阅者 -> 实现一个订阅器 Dep



## 4. 路由守卫

**1.全局路由守卫**

beforeEach(to, from, next) 全局前置守卫，路由跳转前触发

beforeResolve(to, from, next) 全局解析守卫 在所有组件内守卫和异步路由组件被解析之后触发

afterEach(to, from) 全局后置守卫，路由跳转完成后触发

**2.路由独享守卫**

beforeEnter(to,from,next) 路由对象单个路由配置 ，单个路由进⼊前触发

**3.组件路由守卫**

beforeRouteEnter(to,from,next) 在组件⽣命周期beforeCreate阶段触发

beforeRouteUpdadte(to,from,next) 当前路由改变时触发

beforeRouteLeave(to,from,next) 导航离开该组件的对应路由时触发

**4.参数**

to： 即将要进⼊的⽬标路由对象

from： 即将要离开的路由对象

next(Function)：是否可以进⼊某个具体路由，或者是某个具体路由的路径



## 5. Vuex

Vuex有五个核⼼概念：state,getters,mutations,actions,modules

1. state：vuex的基本数据，⽤来存储状态数据
2. getters：从基本数据(state)派⽣的数据，相当于state的计算属性
3. **Mutations**：提交更新数据的方法，必须是同步的(如果需要异步使用action)。每个mutation都有一个字符串的事件类型(type)和一个回调函数(handler)。
4. **Actions**：像一个装饰器，包裹mutations，使之可以异步。
5. **Modules**：对vuex进行模块化，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构更清晰，方便管理。



## 6. 组件通讯（⽗、⼦）

1. ⽗组件向⼦组件传值:⽗组件通过属性的⽅式向⼦组件传值，⼦组件通过 props 来接收

2. ⼦组件向⽗组件传值:⼦组件绑定⼀个事件，通过 this.$emit() 来触发

4. 其他⽅式：缓存、vuex、eventBus事件总线、provide  inject



## 7. 怎么定义vue-router的动态路由？

在router⽬录下的index.js⽂件中，对path属性加上/:id。 使⽤router对象的params.id 



## 8. 2.0和3.0的区别

双向绑定:

V2：使⽤Object.defineProperty

V3：使⽤ES6的新特性proxy来劫持数据，当数据改变时发出通知

根元素:

V2: 必须要有⼀个根元素

V3: ⽆要求

diff算法:

V2: 虚拟Dom全量⽐较

V3: 增加了静态标记PatchFlag

生命周期不同



## 9. computed 与 watch 的区别

computed⽀持缓存，相依赖的数据发⽣改变才会重新计算；watch不⽀持缓存，只要监听的数据变化就会触发相应操作

computed不⽀持异步，当computed内有异步操作时是⽆法监听数据变化的；watch⽀持异步操作

computed属性的属性值是⼀函数，函数返回值为属性的属性值，computed中每个属性都可以设置set与get⽅法。watch监听的数据必须是data中声明过或⽗组件传递过

**computed**

1. 它是计算属性。主要用于值的计算并一般会返回一个值。所以它更多⽤于计算值的场景 
2. 它具有缓存性。当访问它来获取值时，它的 getter 函数所计算出来的值会进行缓存
3. 只有当它依赖的属性值发生了改变，那下⼀次再访问时才会重新调⽤ getter 函数来计算 
4. 它适⽤于计算⽐较消耗性能的计算场景 
5. 必须要有一个返回值

**watch**

1. 它更多的是起到 “观察” 的作⽤，类似于对数据进行变化的监听并执行回调。

   主要⽤于观察 `props` 或 本组件data的值，当这些值发生变化时，执⾏处理操作

2. 不一定要返回某个值

**建议**

1. 当目的是进⾏数值计算，且依赖于其他数据，那么推荐使用 `computed`

2. 当需要在某个数据发生变化的, 同时做⼀些稍复杂的逻辑操作，那么推荐使⽤ `watch`



## 10.Route和router的区别

1. route:是路由信息对象，包括“path,parms,hash,name“等路由信息参数。

2. Router:是路由实例对象，包括了路由跳转⽅法，钩⼦函数等。



## 11.vue-router 路由模式有⼏种？

vue-router 有 3 种路由模式：hash、history、abstract：

hash: 使⽤ URL hash 值来作路由。⽀持所有浏览器，包括不⽀持 HTML5 History Api 的浏览器；

history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；

abstract : ⽀持所有 JavaScript 运⾏环境，如 Node.js 服务器端。如果发现没有浏览器的API，路由会⾃动强制进⼊这个模式.



## 12. Object.defineProperty 和 Proxy 的区别

Object.defineProperty 和 Proxy 的区别如下:

1. Proxy 可以直接监听对象而非属性；&#x20;
2. Proxy 可以直接监听数组的变化；
3. Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等 是 Object.defineProperty 不具备的&#x20;
4. Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改
5. Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准 的性能红利&#x20;
6. Object.defineProperty 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题, 而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重 写



## 13. vue3 新特性有哪些？

1、性能提升

* 响应式性能提升，由原来的 Object.defineProperty 改为基于ES6的 Proxy ，使其速度更快，消除警告。
* 重写了 Vdom ，突破了 Vdom 的性能瓶颈。
* 
* 进行模板编译优化。
* 更加高效的组件初始化

2、更好的支持 typeScript

* 有更好的类型推断，使得 Vue3 把 typeScript 支持得非常好

3、新增Composition API

* Composition API 是 vue3 新增的功能，比 mixin 更强大。它可以把各个功能模块独立开来，提高代码逻辑的可复用性，同时代码压缩性更强

4、新增组件

* Fragment 不再限制 template 只有一个根几点。
* Teleport 传送门，允许我们将控制的内容传送到任意的 DOM 中。
* Supense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验。

5、Tree-shaking：支持摇树优化

* 摇树优化后会将不需要的模块修剪掉，真正需要的模块打到包内。优化后的项目体积只有原来的一半，加载速度更快

6、Custom Renderer API： 自定义渲染器

* 实现 DOM 的方式进行 WebGL 编程



## 14. v-show 与 v-if 区别

v-show和v-if的区别：

v-show是css切换，v-if是完整的销毁和重新创建。

使⽤频繁切换时⽤v-show，运⾏时较少改变时⽤v-if



## 15. vue中v-if和v-for优先级在vue2和vue3中的区别

实践中不管是vue2或者vue3都不应该把v-if和v-for放在一起使用。

* 在 vue 2.x 中，在一个元素上同时使用 v-if 和 v-for 时， v-for 会优先作用。
* 在 vue 3.x 中， v-if 总是优先于 v-for 生效。
* vue2中v-for的优先级是高于v-if的，放在一起，会先执行循环在判断条件，并且如果值渲染列表中一小部分元素，也得再每次重渲染的时候遍历整个列表，比较浪费资源。
* vue3中v-if的优先级是高于v-for的，所以v-if执行时，它调用相应的变量如果不存在，就会导致异常

## 16. script setup 是干啥的？

scrtpt setup 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好。使用 script setup 语法糖的特点：

* 属性和方法无需返回，可以直接使用。
* 引入组件的时候，会自动注册，无需通过 components 手动注册。
* 使用 defineProps 接收父组件传递的值。
* useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。
* 默认不会对外暴露任何属性，如果有需要可使用 defineExpose 。



## 17. reactive与ref的区别？

Vue3 中的 ref 和 reactive 是 Vue3 中用于数据管理的两种不同的响应式 API。

ref 用于创建一个包装简单值的响应式引用，例如一个数字、字符串或对象。当 ref 创建一个响应式引用时，它返回一个对象，该对象具有一个 value 属性，该属性指向实际值。当 ref 返回的对象中的 value 属性更改时，组件将自动重新渲染。

reactive 用于创建一个响应式对象，该对象可以包含多个属性和嵌套属性。当使用 reactive 创建响应式对象时，返回的对象是一个代理对象，该对象具有与原始对象相同的属性，并且任何对代理对象属性的更改都将触发组件的重新渲染。



## 18. v-model的使用？

v-model实现双向绑定的语法糖，常用于表单与组件之间的数据双向绑定.

V-model的原理：

- v-bind绑定一个value属性

- v-on指令给当前元素绑定input事件

可看出v-model绑定在表单上时，v-model其实就是v-bind绑定value和v-on监听input事件的结合体

组件上的双向绑定（原理）

v-model绑定在组件上的时候做了以下步骤

- 在父组件内给子组件标签添加 v-model ，其实就是给子组件绑定了 value 属性
- 子组件内使用 prop 创建 创建 value 属性可以拿到父组件传递下来的值，名字必须是 value。
- 子组件内部更改 value 的时候，必须通过 $emit 派发一个 input 事件，并携最新的值
- v-model 会自动监听 input 事件，把接收到的最新的值同步赋值到 v-model 绑定的变量上



## 19. vuex中的辅助函数怎么使用？

vuex的辅助函数有4个

* mapState 函数返回的是一个对象。通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。
* mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，因此你可以这样来使用他
* mapMutations 辅助函数将组件中的 methods 映射为 store.commit，其原理就是将this.montify 映射为this.\$store.commit(‘montify’)
* mapActions在组件中使用 this.\$store.dispatch('prodect') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用



## 20. slot是什么？有什么作用？原理是什么？

slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。

**slot又分三类，默认插槽，具名插槽和作用域插槽。**

* 默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。
* 具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。
* 作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。

**实现原理：**

当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.\$slot中，默认插槽为vm.\$slot.default具名插槽为vm.\$slot.xxx，xxx 为插槽名

当组件执行渲染函数时候，遇到slot标签，使用slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽

## 21. \$nextTick的使用

用法：将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。

**\$nextTick() 的应用场景**

在vue的生命周期 created() 钩子函数中进行 dom 操作，一定要放在 \$nextTick() 函数中执行。在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的代码放进 nextTick() 的回调函数中。

mounted() 钩子函数，因为该钩子函数执行时，所有的 DOM 挂载和 渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题

在数据变化后要执行某个操作，而这个操作需要随数据改变而改变DOM结构时，这个操作都是需要放置 \$nextTick() 的回调函数中。



## 22. v-for中的key

**语法：** key="唯一值"

**作用：**给列表项添加的**唯一标识**。便于Vue进行列表项的**正确排序复用**。

**为什么加key：**Vue 的默认行为会尝试原地修改元素（**就地复用**）

实例代码：

```js
<ul>
  <li v-for="(item, index) in booksList" :key="item.id">
    <span>{{ item.name }}</span>
    <span>{{ item.author }}</span>
    <button @click="del(item.id)">删除</button>
  </li>
</ul>
```

注意：

1.  **key 的值只能是字符串 或 数字类型**
2.  **key 的值必须具有唯一性**
3.  推荐使用  id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应）



## 23.data必须是一个函数

**1、data为什么要写成函数**

一个组件的 **data** 选项必须**是一个函数**。目的是为了：**保证每个组件实例**，维护**独立**的一份**数据**对象。

每次创建新的组件实例，都会新**执行一次data 函数**，得到一个新对象。



## **24.编程式导航，如何跳转传参？**

1.path路径跳转

- query传参

  ```js
  this.$router.push('/路径?参数名1=参数值1&参数2=参数值2')
  
  this.$router.push({
    path: '/路径',
    query: {
      参数名1: '参数值1',
      参数名2: '参数值2'
    }
  })
  ```

- 动态路由传参

  ```js
  this.$router.push('/路径/参数值')
  
  this.$router.push({
    path: '/路径/参数值'
  })
  ```

2.name命名路由跳转

- query传参

  ```js
  this.$router.push({
    name: '路由名字',
    query: {
      参数名1: '参数值1',
      参数名2: '参数值2'
    }
  })
  ```

- 动态路由传参 (需要配动态路由)

  ```js
  this.$router.push({
    name: '路由名字',
    params: {
      参数名: '参数值',
    }
  })
  ```

## 25. 什么是 M V  VM

`Model-View-ViewModel 模式`



<img src="web/面试/面试加强/02-笔记/前端面试手册.assets/image-20210223221853817.png" alt="image-20210223221853817" style="zoom:100%;" />



**Model 层**: `数据模型层`

通过 `Ajax`、`fetch` 等 API 完成客户端和服务端业务模型的同步。



**View 层**: `视图层`

作为视图模板存在，其实View 就是⼀个动态模板。



**ViewModel 层**: `视图模型层`

负责暴露数据给 View 层，并对 View 层中的数据绑定声明、 指令声明、 事件绑定声明, 进行实际的业务逻辑实现。

**`数据变化了, 视图自动更新`** => ViewModel 底层会做好监听Object.defineProperty，当数据变化时，View 层会自动更新

**`视图变化了, 绑定的数据自动更新`** =>  会监听双向绑定的表单元素的变化，⼀旦变化，绑定的数据也会得到⾃动更新。



## 26. MVVM的优缺点有哪些？

**优点**

1. 实现了视图（View）和模型（Model）的分离，降低代码耦合、提⾼视图或逻辑的复⽤性

2. 提⾼了可测试性：ViewModel 的存在可以帮助开发者更好地编写测试代码 

3. 能⾃动更新 DOM：利⽤双向绑定，数据更新后视图⾃动更新，让开发者从繁琐的⼿动操作 DOM 中解放出来 

**缺点**

1. Bug 难被调试：因为使⽤了双向绑定的模式，当我们看到界⾯发生异常了，有可能是 View 的代码产生的 Bug，

   也有可能是Model 代码的问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，

   要定位原始出问题的地⽅就变得不那么容易了

   可采用的`调试方案`:

   ```是登录校验通过之后，直接调用接口，获取token之后，跳转到主页。


- vue-element-admin的登录思路：

1. 登录表单校验通过
2. 调用Vuex提供的登录的action
3. 登录的Action中会调用接口
4. 登录接口如果成功执行，会返回token
5. 利用Vuex的特性，将token共享的到Vuex中，这样Vuex就统一管理了token,别的地方想要使用，直接通过Vuex就可以
6. 登录接口会调用单独封装的请求模块(api)
7. 请求模块中又会使用用到axios封装的请求工具
8. 而请求工具又要考虑区分 开发环境和生产环境的问题
9. 请求时还要考虑前后分离项目产生的跨域问题，要使用代理解决跨域



## 2.登录模块业务实现思路

1. 首先设计并开发出登录页面的静态页面，设置Rules校验函数，对手机号和密码实现校验。基础校验和统一校验。
2. 使用token 信息作为用户登录的唯一标识，并且存储在LocalStorage中，通过Vuex 统一管理token ，并且实现token 的持久化。
3. 利用 axios 中设置请求拦截器，在每次请求的请求头中，注入 token 信息，作为登录的标识。
4. 配合Vue-Router 中的beforeEach 前置导航守卫函数，实现对 token 信息的统一监测，和拦截登录。



## 3.主页模块的实现思路

1. 登录成功后，根据业务的需求，配合suss 实现对样式的二次修改。
2. 初始化 Vuex 中的 mutations 信息，更新登录后用户的信息收集，封装 action 获取用户资料
3. 利用 Vuex 中的 getters 属性，完成用户登陆后的视图层渲染
4. 封装 action ，实现用户退出登录，调用 commit 方法，清除 Vuex 中保存的 token 信息
5. 根据后端检测 token 返回的状态码，设置拦截器，对失效 token 信息实现拦截登录，并提示用户token失效



## 4.登录流程

1. 拉取 vue-admin-template 代码，进行一些改造。

2. 设计并且开发登录页面，进行表单校验，基础校验 + 统一校验

   ```html
   <!--
    基础校验
   el-form  :model="表单对象"  :rules="规则对象"
   el-form-item  prop属性指定一下要使用哪条规则
   el-input v-model双向绑定
   
   统一校验
   1. 获取表单的实例对象
   2. 调用validate方法    const res = await this.$refs.loginForm.validate() 
   -->
   ```

3. Vuex 中实现用户的模块

   1. 删除模板中原有的内容进行重写  

   2. 开启命名空间，导出 vuex 子模块

   3. 实现 token 的vue数据持久化   

      ```js
      1. 存Token数据时，一份存入vuex，一份存入cookie
      2. vuex中初始化Token时，优先从本地cookie取，取不到再初始化为空串儿
      ```

   4. 实现登录的actions方法

      ```js
      login() {
            this.$refs.form.validate((isOK) => {
              if (isOK) {
                this.$store.dispatch("user/login", this.loginForm)
              }
            })
          }
      ```

4. Vue-cli 代理解决跨域：配置文件可以直接配置代理 vue.config.js  -> devServer  ->  proxy -> api

5. axios 二次封装，将 `axios `请求方法，封装到 request 模块

   1. 配置基础地址  ，超出时间

   2. 请求拦截器 - 根据获取仓库中的token 来判断  然后 在header 中统一注入 token

   3. 响应拦截器 - 解构数据  -  处理异常

      ```js
      // 通用配置
      // 1. axios实例化  axios.create() 基地址配置 baseURL + 超时时间 timeout（100ms）
      // 拓展：create方法可以调用多次 每次执行都会生成一个独一无二的实例
      // export default const a = asiox.create({ baseURL: 'a.com' })
      // export default const b = asiox.create({ baseURL: 'b.com' })
      
      // 2. 请求拦截器  请求头中添加token数据  接口鉴权  统一配置
      // 客户端发送请求 - 请求拦截器(针对请求参数做处理) - 后端
      // 拓展：可以添加多个请求拦截器
      // 客户端请求 - 拦截器1(处理参数) - 拦截器2 - 后端 
      // 最后一定要return  config  失败就执行promise.reject(error)
      
      // 3. 响应拦截器 数据剥离 res.data / token失效401错误处理 / 前端自定义错误处理？ 
      // 后端 - 响应拦截器 - 客户端
      // 成功回调 200-300
      // 失败回调 不在这个之间
      // axios默认包裹了一层data 把响应数据解构出来  判断如果业务成功 返回用户所需要的数据   业务失效 错误提示  return 一个error  （new一个）
      // // 所有的响应错误信息，统一处理
      
      ```

6. 封装 api 接口

   **将请求封装成方法，统一存放到 api 模块，与页面分离,可维护性高**

   新建 `api/user.js` 提供注册 Api 函数

   ```jsx
   import request from '@/utils/request'
   
   // 注册接口
   export const register = (data) => {
     return request.post('/user/register', data)
   }
   ```

   

7. 区分环境（表单）

   1. 开发环境  developent
   2. 生产环境   production

8. 登录联调

   1. 封装登录的api
   2. vuex 中的用户模块调用登录接口
   3. 登录成功后，跳转到主页
   4. 区分表单不同环境下的不同数据

9. 主页鉴权验证

   1. 访问主页-有token放过，没有token跳到登录页
   2. 访问登录-有token跳到主页，没有token放过
   3. 前置守卫 - beforeEach 中 来处理逻辑  白名单



## 5.智慧园区

### 1.搜索功能

  思路分析：把各种搜索条件当作请求参数发给后端 后端会根据字段对数据库数据做过滤筛选拿到符合条件返回

            1. 表单组件的双向绑定收集到当前的请求数据
            2. 把收集到的表单参数发送接口给后端那符合条件的数据
            3. 把拿到的数据关系显示在列表中



### 2.excel导出

1. 实际开发过程中的导出

   1. 前端主导（xlsx）

      流程：调用列表接口把要导出的数据拿到 -> 数据的二次转化  ->  [excel 工作簿 - 工作表 - 单元格数据] - 使用xlsx创建一个工作簿 - 使用xlsx方法创建一个工作表 - 把工作表添加到工作簿 -- [使用中文替换中文表头] 调用xlsx的导出方法

      工作中遇到了需求，参考代码 换接口 数据二次处理 处理表头

   2. 后端主导（最常见）

      流程：前端直接调用导出接口 - 后端会把数据转换成excel文件流当成返回值返回 - 直接触发浏览器的下载功能

2. 两种方案的本质区别：

   把数据转化成excel的过程发生在哪里？如果发生在浏览器 前端主导 如果发生在后端服务器 后端主导

   前端主导 - 处理数据量不能太大

   后端主导 - 适合处理量大或量小都可



